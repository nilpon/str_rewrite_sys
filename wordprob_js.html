<!DOCTYPE html>
<html>
	<head>
		<title>Word Problem</title>
		<meta charset="utf-8"/>
		<script src="wordprob.js"></script>
		<script src="tab.js"></script>
		<link rel="stylesheet" href=wordprob.css>
	</head>
	<body>
	<h1>Monoid書換え系シミュレータ</h1>
	Monoid:
	<select id="list_monoid" onChange="change_monoid()">
		<option value="0">monoid0</option>
	</select>
	<input type="button" onclick="btn_change_monoidname()" value="名前変更">
	<input type="button" onclick="btn_new_monoid()" value="新規">
	<input type="button" onclick="btn_remove_monoid()" value="削除">
	<input type="button" onclick="btn_remove_all_monoid()" value="全削除">
	
	<hr>

	<div id="working_area"></div>

	<script language="javascript" type="text/javascript">
	let monlist = [];
	monlist.push(new Monoid);
	let mon = monlist[0];
	mon.name = "monoid0";
	let resol_max = 10000;
	let max_overlap = 50;

	// array of [word, replace_begin, left, right, monoid_name]
	let calc_history = [];
	let use_right2left = false;

	let tab_working_area = Tab.new("working_area");
	let page_relation = construct_relation_page();
	let page_calc = construct_calc_page();
	let page_conf = construct_config_page();
	let page_save = construct_save_page();

	Tab.onclick(tab_working_area, page_relation);

	function set_text(elem, txt) {
		elem.appendChild(document.createTextNode(txt));
	}

	function set_span_text(elem, txt, classname) {
		let span = document.createElement("span");
		if(classname) span.setAttribute("class", classname);
		span.innerText = txt;
		return elem.appendChild(span);
	}

	function set_textbox(elem, id, value, onfocus = null, readonly = false) {
		let txtbox = document.createElement("input");
		txtbox.setAttribute("type", "text");
		txtbox.setAttribute("id", id);
		txtbox.setAttribute("value", value);
		txtbox.setAttribute("spellcheck", false);
		if(onfocus) {
			txtbox.setAttribute("onfocus", onfocus);
		}
		if(readonly) {
			txtbox.readOnly = true;
		}

		return elem.appendChild(txtbox);
	}

	function set_button(elem, txt, onclick) {
		let btn = document.createElement("input");
		btn.setAttribute("type", "button");
		btn.setAttribute("value", txt);
		btn.setAttribute("onclick", onclick);

		return elem.appendChild(btn);
	}

	function set_div(elem, id, classname) {
		let div = document.createElement("div");
		if(id) div.setAttribute("id", id);
		if(classname) div.setAttribute("class", classname);
		return elem.appendChild(div);
	}

	function set_br(elem) {
		elem.appendChild(document.createElement("br"));
	}

	function set_hr(elem) {
		elem.appendChild(document.createElement("hr"));
	}

	function set_checkbox(elem, id, onclick) {
		let btn = document.createElement("input");
		btn.setAttribute("type", "checkbox");
		if(id) btn.setAttribute("id", id);
		if(onclick) btn.setAttribute("onclick", onclick);

		elem.appendChild(btn);
	}

	function construct_relation_page() {
		let cntarea = document.createElement("div");

		set_text(cntarea, "新しい関係式:");
		set_textbox(cntarea, "relation_left", "");
		set_text(cntarea, " = ");
		set_textbox(cntarea, "relation_right", "");
		set_button(cntarea, "追加", "btn_add_relation()");
		set_button(cntarea, "生成元の位数", "btn_add_exp_relation()");
		set_br(cntarea);

		set_button(cntarea, "整列", "btn_sort()");
		set_button(cntarea, "簡約", "btn_reduce_relations()");
		set_button(cntarea, "Knuth-Bendix", "btn_KB()");
		set_button(cntarea, "全選択", "btn_selall()");
		set_button(cntarea, "消去", "btn_erase()");
		set_button(cntarea, "合流的か？", "btn_confluence()");
		set_button(cntarea, "派生Monoid生成", "btn_gen_submon()");
		set_button(cntarea, "全組合せで生成", "btn_gen_submon_all()");

		set_div(cntarea, "relation_view");
		return Tab.newpage(tab_working_area, "関係式一覧", cntarea.innerHTML, page_update);
	}

	function construct_save_page() {
		let cntarea = document.createElement("div");

		set_text(cntarea, "セーブデータ:");
		set_textbox(cntarea, "save_txtbox", "", "this.select()");
		set_button(cntarea, "インポート", "btn_import()");

		return Tab.newpage(tab_working_area, "セーブ", cntarea.innerHTML, btn_export);
	}

	function construct_config_page() {
		let cntarea = document.createElement("div");

		set_text(cntarea, "Knuth-Bendix procedure の計算量制御");
		set_br(cntarea);
		set_text(cntarea, "overlap解消処理の最大実行回数(0は無制限):");
		set_textbox(cntarea, "resol_limit_txt", "" + resol_max);
		set_br(cntarea);
		set_text(cntarea, "長いoverlapは無視する(0は無制限):");
		set_textbox(cntarea, "overlap_limit_txt", "" + max_overlap);
		set_button(cntarea, "決定", "btn_set_limit()");
		set_br(cntarea);
		set_text(cntarea, "！注意！");
		set_br(cntarea);
		set_text(cntarea, "※値が大きい(特に無制限だ)と処理が永遠に終わらないかもしれません！");
		set_br(cntarea);
		set_text(cntarea, "※そもそも合流的な有限関係式系が存在しない、永遠に計算不能な例が実在します。");
		set_br(cntarea);
		set_text(cntarea, "※無制限でない場合は結果が未だ合流的でない可能性が残っています。合流的か？ボタンで検証できるよ！");
		set_br(cntarea);
		set_text(cntarea, "※制限によって強制中断されても、結果はmonoidとしては変わっていないので安心してね！(ﾟ∀ﾟ∩");

		return Tab.newpage(tab_working_area, "設定", cntarea.innerHTML, show_cur_limit);
	}

	function construct_calc_page() {
		let cntarea = document.createElement("div");

		set_textbox(cntarea, "word_txt", "");
		set_button(cntarea, "入力", "btn_calc_begin()");
		set_button(cntarea, "元に戻す", "btn_rollback()");
		set_button(cntarea, "履歴をクリア", "btn_hist_clear()");
		set_checkbox(cntarea, "is_right2left", "draw_manip_candicates()");
		set_text(cntarea, "逆変形");
		
		set_div(cntarea, "history_area", "history_area");
		set_div(cntarea, "manip_area");

		return Tab.newpage(tab_working_area, "計算", cntarea.innerHTML, on_move_to_calc_page);
	}

	function btn_add_relation() {
		let rel_left = sanitize(document.getElementById("relation_left").value);
		let rel_right = sanitize(document.getElementById("relation_right").value);
		mon.add_relation(rel_left, rel_right);
		page_update();
	}

	function page_update() {
		show_monoid_list();
		set_mon();
		show_relations();
	}

	function show_relations() {
		let rel_view = document.getElementById("relation_view");

		if(rel_view) {
			rel_view.innerHTML = "";
			let rel_view_form = document.createElement("form");
			rel_view_form.setAttribute("name", "rel_checkboxes");

			let counter = 1;
			for(const rel of mon.relations) {
				let chkbox = document.createElement("input");
				chkbox.setAttribute("type", "checkbox");
				chkbox.setAttribute("name", "rels");
				rel_view_form.appendChild(chkbox);
				
				let relation_txt = "" + counter + ". ";
				if(rel.second.length) {
					relation_txt += rel.first + " = " + rel.second;
				}
				else {
					relation_txt += rel.first + " = ε";
				}
				rel_view_form.appendChild(document.createTextNode(relation_txt));
				rel_view_form.appendChild(document.createElement("br"));

				counter++;
			}
			if(!mon.relations.length) {
				rel_view_form.appendChild(document.createTextNode("なし"));
			}

			rel_view.appendChild(rel_view_form);
		}
	};

	function show_monoid_list() {
		let list_monoid = document.getElementById("list_monoid");
		let selected = list_monoid.selectedIndex;

		while(list_monoid.lastChild) list_monoid.removeChild(list_monoid.lastChild);
		for(let i = 0; i < monlist.length; i++) {
			let option = document.createElement("option");
			option.setAttribute("value", i);
			option.innerHTML = monlist[i].name;
			list_monoid.appendChild(option);
		}

		if(selected >= monlist.length) selected = monlist.length - 1;
		list_monoid.options[selected].selected = true;
	}

	function btn_sort() {
		mon.sort_relations();
		page_update();
	}

	function btn_KB() {
		console.time("Knuth-Bendix");
		mon.Knuth_Bendix(resol_max, max_overlap);
		console.timeEnd("Knuth-Bendix");
		page_update();
	}

	function btn_reduce_relations() {
		mon.reduce_relations();
		// remove inactive relations
    mon.relations = mon.relations.filter( function (rel) {
      return rel.first;
    });
		page_update();
	}

	function btn_selall() {
		let myrels = document.rel_checkboxes.rels;
		
		if(myrels) {
			if(myrels.length > 1) {
				for(const box of myrels) {
					box.checked = true;
				}
			}
			else {
				myrels.checked = true;
			}
		}
	}

	function btn_erase() {
		let myrels = document.rel_checkboxes.rels;
		let counter = 0;
		
		if(myrels) {
			let index_list = [];
			if(myrels.length > 1) {
				for(const box of myrels) {
					if(box.checked) index_list.push(counter);
					counter++;
				}
			}
			else {
				if(myrels.checked) index_list.push(0);
			}
			mon.remove_relations(index_list);
			page_update();
		}
	}

	function btn_confluence() {
console.time("confluence");
		is_confl = mon.confluence();
console.timeEnd("confluence");
		if(!is_confl) alert("合流的ですO(^o^)O");
		else alert("合流的じゃない;O(>o<)O;\nfailed at: " + is_confl);
	}

	function set_mon() {
		let listbox = document.getElementById("list_monoid");
		mon = monlist[listbox.options[listbox.selectedIndex].value];
	}

	function change_monoid() {
		page_update();
	}

	function btn_change_monoidname() {
		let listbox = document.getElementById("list_monoid");
		
		let newname = sanitize(window.prompt(monlist[listbox.selectedIndex].name + "の新しい名前", monlist[listbox.selectedIndex].name));
		if(newname) {
			monlist[listbox.selectedIndex].name = newname;
			page_update();
		}
	}

	function monoid_list_select(index) {
		let list_monoid = document.getElementById("list_monoid");
		if(index >= monlist.length) index = monlist.length - 1;
		list_monoid.options[index].selected = true;
		page_update();
	}

	function btn_new_monoid(name_cand = "") {
		if(!name_cand) name_cand = "monoid" + monlist.length;

		let newname = sanitize(window.prompt("新しいMonoidの名前", name_cand));
		if(newname) {
			let newmon = new Monoid;
			newmon.name = newname;
			monlist.push(newmon);
			page_update();
			monoid_list_select(monlist.length - 1);
		}

		return newname;
	}

	function btn_remove_monoid() {
		let listbox = document.getElementById("list_monoid");

		if(monlist.length <= 1) {
			alert("最後の一つは削除できません！");
			return;
		}

		if(confirm("本当に" + monlist[listbox.selectedIndex].name + "を削除しますか(´・ω・`)？")) {
			monlist.splice(listbox.selectedIndex, 1);
			page_update();
		}
	}

	function btn_gen_submon() {
		let list_monoid = document.getElementById("list_monoid");
		let name_cand = monlist[list_monoid.selectedIndex].name + "_sub";
		let newrellist = [];
		let myrels = document.rel_checkboxes.rels;
		
		if(myrels) {
			let counter = 0;
			if(myrels.length > 1) {
				for(const box of myrels) {
					if(box.checked) {
						name_cand += counter + 1;
						let reltoadd = mon.relations[counter];
						newrellist.push(new Relation(reltoadd.first, reltoadd.second));
					}
					counter++;
				}
			}
			else {
				if(myrels.checked) newrellist.push(mon.relations[0]);
			}

			if(btn_new_monoid(name_cand)) {
				mon.relations = newrellist.slice();
			}
			page_update();
		}
	}

	function btn_gen_submon_all() {
		let list_monoid = document.getElementById("list_monoid");
		let name_cand = monlist[list_monoid.selectedIndex].name + "_sub";
		let selectedrellist = [], fixedrellist = [];
		let selectedidlist = [];
		let myrels = document.rel_checkboxes.rels;

		
		
		if(myrels) {
			let counter = 0;
			if(myrels.length > 1) {
				for(const box of myrels) {
					let reltoadd = mon.relations[counter];
					if(box.checked) {
						selectedidlist.push(counter + 1);
						selectedrellist.push(reltoadd);
					}
					else {
						fixedrellist.push(reltoadd);
					}
					counter++;
				}
			}
			else return; // trivial and no use

			if(!selectedrellist.length) {
				alert("関係式を選択してね！");
				return;
			}
			if(selectedrellist.length >= 13) {
				alert("パターン大杉！！(ﾟAﾟ;)");
				return; // absurd!!!
			}

			if(!confirm("選んだ関係式全ての組合せを生成します。よろしいですか？(ﾟAﾟ;)")) return;

			if(selectedrellist.length >= 7 && (!confirm("Seriously?(ﾟAﾟ;;)") || !confirm("何百個も生成されるけど、ほんとにいいの!?(ﾟAﾟ;;;)"))) {
				return;
			}

			for(let i = 0; i < (1 << selectedrellist.length) - 1; i++) {
				let sublist = fixedrellist.slice();
				let submonname = name_cand;
				console.log(i);
				for(let j = 0; j < selectedrellist.length; j++) {
					if(i & (1<<j)) {
						submonname += selectedidlist[j];
						sublist.push(selectedrellist[j]);
					}
				}
				let new_submon = new Monoid;
				for(const rel of sublist) {
					new_submon.relations.push(new Relation(rel.first, rel.second));
				}
				new_submon.name = submonname;
				monlist.push(new_submon);
			}
			page_update();
		}
	}

	function sanitize(text) {
		if(text) return text.replace(/[\x00-\x20<=>"'&\x7f-\x9f]/g, "");
		else return "";
	}

	// format: monname0<rel0f=rel0s&rel1f=rel1s&...>monname1...
	function btn_export() {
		monlist_data = "";
		for(let i = 0; i < monlist.length; i++) {
			monlist_data += monlist[i].name + "<";
			for(const rel of monlist[i].relations) {
				monlist_data += rel.first + "=" + rel.second + "&";
			}
			monlist_data += ">";
		}
		monlist_data = monlist_data.replace(/&>/g, ">");

		let txtbox = document.getElementById("save_txtbox");

		if(txtbox) txtbox.setAttribute("value", monlist_data);
	}

	function btn_import() {
		let importraw = document.getElementById("save_txtbox").value;
		if(importraw) {
			let import_monlist = importraw.split(">");
			let new_monlist = [];
			for(const montxt of import_monlist) {
				if(!montxt) continue;
				let import_name_and_relation = montxt.split("<");
				if(import_name_and_relation.length != 2) {
					alert("データが破損しています！");
					return;
				}

				let myname = sanitize(import_name_and_relation[0]);
				if(!myname) {
					alert("データが破損しています！");
					return;
				}

				let mymon = new Monoid;
				mymon.name = myname;
				let import_relations = import_name_and_relation[1].split("&");
				for(const reltxt of import_relations) {
					if(!reltxt) continue;
					let relsplit = reltxt.split("=");
					if(relsplit.length != 2) {
						alert("データが破損しています！");
						return;
					}

					let rel_left = sanitize(relsplit[0]);
					let rel_right = sanitize(relsplit[1]);
					mymon.add_relation(rel_left, rel_right);
				}
				new_monlist.push(mymon);
			}

			if(new_monlist.length) {
				monlist = new_monlist;
				monoid_list_select(0);

				alert("インポートしました！");
			}
		}
	}

	function show_cur_limit() {
		document.getElementById("resol_limit_txt").value = "" + resol_max;
		document.getElementById("overlap_limit_txt").value = "" + max_overlap;
	}

	function btn_set_limit() {
		let new_resol_limit = parseInt(document.getElementById("resol_limit_txt").value);
		let new_overl_limit = parseInt(document.getElementById("overlap_limit_txt").value);

		// luckly, NaN >= 0 is false!
		if(new_resol_limit >= 0 && new_overl_limit >= 0) {
			resol_max = new_resol_limit;
			max_overlap = new_overl_limit;
		}
	}

	function btn_add_exp_relation() {
		let generators = sanitize(window.prompt("位数を指定する生成元(一括で複数指定可能)", ""));
		if(generators) {
			// eliminate duplicates
			let gen_split = generators.split("");
			generators = gen_split.filter((x, i, self) => self.indexOf(x) === i);

			let order = parseInt(sanitize(window.prompt(generators.join() + "の位数(1～1000)", "2")));
			if(order >= 1 && order <= 1000) {
				for(const elem of generators) {
					mon.add_relation(elem.repeat(order), "");
				}
				page_update();
			}
		}
	}

	function btn_remove_all_monoid() {
		if(confirm("Monoidを*全て*削除し初期化します。よろしいですか(´・ω・`)？")) {
			if(confirm("ほんとにいいですか(´；ω；`)")) {
				monlist.splice(0);

				monlist.push(new Monoid);
				mon = monlist[0];
				mon.name = "monoid0";
				
				page_update();
			}
		}
	}

	function view_calc() {
		draw_history();
		draw_manip_candicates();
	}

	function btn_calc_begin() {
		let txtbox = document.getElementById("word_txt");
		
		if(!txtbox) return;

		calc_history.push([sanitize(txtbox.value), -1, "", "", mon.name]);
		view_calc();
	}

	function manip_candicates(cur_word) {
		let manips = [];
		let chkbox = document.getElementById("is_right2left");

		if(!chkbox) return;
		use_right2left = chkbox.checked;

		for(const rel of mon.relations) {
			let i = -1;
			while((i = cur_word.indexOf(rel.first, i + 1)) != -1) {
				manips.push([i, rel.first, rel.second]);
				if(i >= cur_word.length - 1) break;
			}
			if(use_right2left) {
				if(!rel.second.length) {// insertion
					manips.push([-1, rel.second, rel.first]);
				}
				else {
					let i = -1;
					while((i = cur_word.indexOf(rel.second, i + 1)) != -1) {
						manips.push([i, rel.second, rel.first]);
						if(i >= cur_word.length - 1) break;
					}
				}
			}
		}
		
		return manips;
	}

	function draw_manip_candicates() {
		let manip_area = document.getElementById("manip_area");
		if(!manip_area) return;
		manip_area.innerHTML = "";
		if(!calc_history.length) return;

		cur_word = calc_history.slice(-1)[0][0];
		
		manips = manip_candicates(cur_word);
		if(!manips) return;

		let line_count = 0;
		for(const manip of manips) {
			let manip_line = set_div(manip_area, "manip_btn" + line_count);

			if(manip[0] < 0) { // insertion
				set_button(manip_line, "挿入", "draw_insert_manip(\"manip_btn" + line_count + "\")");
				set_text(manip_line, manip[2]);
				set_div(manip_line).style.marginLeft = "1em"; // insert command area
			}
			else {
				set_button(manip_line, "適用", "btn_apply_manip(" + manip[0] + "," + manip[1].length + ",\"" + manip[2] + "\")");
				set_text(manip_line, cur_word.substr(0, manip[0]));
				set_span_text(manip_line, manip[1], "relator");
				set_text(manip_line, cur_word.substr(manip[0] + manip[1].length));
				set_text(manip_line, " = ");
				set_text(manip_line, cur_word.substr(0, manip[0]));
				if(manip[2].length) { // no need to show empty word
					set_span_text(manip_line, manip[2], "relator");
				}
				else { // but in case cur_word == manip[1] and vanish
					if(cur_word === manip[1]) set_text(manip_line, "ε");
				}
				set_text(manip_line, cur_word.substr(manip[0] + manip[1].length));
			}
			line_count++;
		}
	}

	function draw_insert_manip(id) {
		let mymanip = document.getElementById(id);
		if(!mymanip) return;

		cur_word = calc_history.slice(-1)[0][0];
		
		if(mymanip.firstChild.value == "挿入") {
			mymanip.firstChild.value = "閉じる";
			let manip_line = mymanip.lastChild;
			let word_to_insert = mymanip.childNodes[1].data;
			
			for(let i = 0; i <= cur_word.length; i++) {
				set_button(manip_line, "適用", "btn_apply_manip(" + i + "," + 0 + ",\"" + word_to_insert + "\")");
				set_text(manip_line, cur_word.substr(0, i));
				set_span_text(manip_line, "^", "relator");
				set_text(manip_line, cur_word.substr(i));
				set_text(manip_line, " = ");
				set_text(manip_line, cur_word.substr(0, i));
				set_span_text(manip_line, word_to_insert, "relator");
				set_text(manip_line, cur_word.substr(i));
				set_br(manip_line);
			}
		}
		else {
			mymanip.firstChild.value = "挿入";
			mymanip.lastChild.innerHTML = "";
		}
	}

	function btn_apply_manip(offset, leftlen, right) {
		let i = parseInt(offset);
		let len = parseInt(leftlen);
		let lasthist = calc_history.pop();
		if(!lasthist) return;

		let cur_word = lasthist[0];
		lasthist[1] = i;
		lasthist[2] = cur_word.substr(i, len);
		lasthist[3] = right;
		lasthist[4] = mon.name;
		calc_history.push(lasthist);

		let new_word = cur_word.substr(0, i) + right + cur_word.substr(i + len);
		calc_history.push([new_word, -1, "", "", mon.name]);
		view_calc();
	}

	function scroll_to_recent_history() {
		let history_area = document.getElementById("history_area");
		if(!history_area) return;

		history_area.scrollTop = history_area.scrollHeight;
	}


	function draw_history() {
		let history_area = document.getElementById("history_area");
		if(!history_area) return;
		history_area.innerHTML = "";

		let is_first = true;
		for(const hist of calc_history) {
			let cur_line = set_span_text(history_area, "");
			if(!is_first) {
				set_text(cur_line, " = ");
			}
			else is_first = false;

			if(hist[1] >= 0) {
				set_text(cur_line, hist[0].substr(0, hist[1]));
				if(!hist[2].length) { // replacing empty word
					set_span_text(cur_line, "^", "relator");
				}
				else {
					set_span_text(cur_line, hist[2], "relator");
				}
				set_text(cur_line, hist[0].substr(hist[1] + hist[2].length));

				let left = hist[2];
				if(!left.length) left = "ε";
				let right = hist[3];
				if(!right.length) right = "ε";
				set_span_text(history_area, " :" + left + " = " + right + " @" + hist[4]).style.marginLeft = "" + (220 - cur_line.getBoundingClientRect().width % 200) + "px";
				set_br(history_area);
			}
			else {
				let cur_word = hist[0];
				if(!cur_word) cur_word = "ε";
				set_text(cur_line, cur_word);
				set_hr(history_area);
				is_first = true;
			}
		}
		scroll_to_recent_history();
	}

	function on_move_to_calc_page() {
		let txtbox = document.getElementById("word_txt");
		if(!txtbox) return;

		if(calc_history.length) {
			// set current word to input textbox
			txtbox.value = calc_history[calc_history.length - 1][0];
		}

		let chkbox = document.getElementById("is_right2left");
		if(!chkbox) return;
		chkbox.checked = use_right2left;

		scroll_to_recent_history();
		draw_manip_candicates(); // monoid may be changed!
	}

	function btn_rollback() {
		calc_history.pop();
		if(calc_history.length) {
			// erase last manipulation info in order not to display it
			calc_history[calc_history.length - 1][1] = -1;
		}
		view_calc();
	}

	function btn_hist_clear() {
		calc_history = [];
		view_calc();
	}

/*
	function btn_auto_reduce() {
		let w = sanitize(current_word);

		while(
			mon.relations.some(
				function(rel) {
					let relator_found = false;
          w = w.replace(rel.first, function() {relator_found = true; return rel.second;});
          
					return relator_found;
				}
			)
		);
	}
*/

  </script>
	</body>
</html>
